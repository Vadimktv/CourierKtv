
generator client {
    provider = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
    output = "/home/ubuntu/receipt-analyzer/app/node_modules/.prisma/client"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// NextAuth models
model Account {
    id                String  @id @default(cuid())
    userId            String  @map("user_id")
    type              String
    provider          String
    providerAccountId String  @map("provider_account_id")
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@map("accounts")
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique @map("session_token")
    userId       String   @map("user_id")
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("sessions")
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String    @unique
    emailVerified DateTime? @map("email_verified")
    image         String?
    password      String    // Hashed password
    role          String    @default("courier") // courier, restaurant, admin
    phone         String?
    city          String?
    
    // Relations
    accounts      Account[]
    sessions      Session[]
    receipts      Receipt[]
    orders        Order[]
    shifts        Shift[]
    
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt

    @@map("users")
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
    @@map("verificationtokens")
}

model Receipt {
    id           String   @id @default(cuid())
    fileName     String
    fileSize     Int
    fileType     String
    uploadedAt   DateTime @default(now())
    processedAt  DateTime?
    ocrStatus    String   @default("pending") // pending, processing, completed, failed
    rawOcrText   String?
    
    // User relation
    userId       String
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    
    // Extracted data
    orders       Order[]
    
    @@map("receipts")
}

model Order {
    id              String   @id @default(cuid())
    receiptId       String
    receipt         Receipt  @relation(fields: [receiptId], references: [id], onDelete: Cascade)
    
    // User relation
    userId          String
    user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    
    // Restaurant/establishment info
    restaurantName  String?
    
    // Delivery info
    deliveryAddress String?
    entrance        String?
    floor           String?
    apartment       String?
    phoneNumber     String?
    
    // Order details
    orderAmount     Float?
    paymentMethod   String?  // cash, card, online
    orderNumber     String?
    
    // Coordinates for route building
    latitude        Float?
    longitude       Float?
    
    // Status and metadata
    status          String   @default("active") // active, completed, cancelled
    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt
    
    // New fields for completion functionality
    completedAt     DateTime?
    finalPaymentMethod String? // "paid", "terminal", "transfer", "cash"
    confirmedAmount Float?
    zone            String?  // "purple", "blue", "red", "green"
    earnings        Float?
    
    // Enhanced OCR fields
    isYandexFood    Boolean? @default(false)
    paymentWarning  String?
    
    // Relations
    shift           Shift?   @relation(fields: [shiftId], references: [id])
    shiftId         String?
    
    @@map("orders")
}

model DeliveryZone {
    id          String   @id @default(cuid())
    name        String   @unique // "purple", "blue", "red", "green"
    displayName String   // "Фиолетовая", "Синяя", "Красная", "Зеленая"
    rate        Float    // Price per delivery
    color       String   // Hex color code
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    
    @@map("delivery_zones")
}

model Shift {
    id          String   @id @default(cuid())
    startTime   DateTime @default(now())
    endTime     DateTime?
    isActive    Boolean  @default(true)
    totalOrders Int      @default(0)
    totalEarnings Float  @default(0)
    
    // User relation
    userId      String
    user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    
    // Zone statistics
    purpleCount Int     @default(0)
    blueCount   Int     @default(0)
    redCount    Int     @default(0)
    greenCount  Int     @default(0)
    
    purpleEarnings Float @default(0)
    blueEarnings   Float @default(0)
    redEarnings    Float @default(0)
    greenEarnings  Float @default(0)
    
    orders      Order[]
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    
    @@map("shifts")
}

model ProcessingStats {
    id                String   @id @default(cuid())
    date              DateTime @default(now())
    receiptsProcessed Int      @default(0)
    ordersExtracted   Int      @default(0)
    avgProcessingTime Float?
    
    @@map("processing_stats")
}
